// +build ignore

package main

import (
	"fmt"
	"os"
	"text/template"
)

// This generates the common export functions to reduce boilerplate in plugins

const exportTemplate = `package main

// Code generated by go generate; DO NOT EDIT.

// #cgo CFLAGS: -I../../include/clap/include
// #include "../../include/clap/include/clap/clap.h"
// #include <stdlib.h>
import "C"
import (
	"runtime/cgo"
	"unsafe"
	
	"github.com/justyntemme/clapgo/pkg/api"
)

//export ClapGo_GetVersion
func ClapGo_GetVersion(major, minor, patch *C.uint32_t) C.bool {
	if major != nil { *major = C.uint32_t(1) }
	if minor != nil { *minor = C.uint32_t(0) }
	if patch != nil { *patch = C.uint32_t(0) }
	return C.bool(true)
}

//export ClapGo_GetPluginID
func ClapGo_GetPluginID(pluginID *C.char) *C.char {
	return C.CString(PluginID)
}

//export ClapGo_GetPluginName
func ClapGo_GetPluginName(pluginID *C.char) *C.char {
	return C.CString(PluginName)
}

//export ClapGo_GetPluginVendor
func ClapGo_GetPluginVendor(pluginID *C.char) *C.char {
	return C.CString(PluginVendor)
}

//export ClapGo_GetPluginVersion
func ClapGo_GetPluginVersion(pluginID *C.char) *C.char {
	return C.CString(PluginVersion)
}

//export ClapGo_GetPluginDescription
func ClapGo_GetPluginDescription(pluginID *C.char) *C.char {
	return C.CString(PluginDescription)
}

//export ClapGo_PluginInit
func ClapGo_PluginInit(plugin unsafe.Pointer) C.bool {
	return C.bool(getPlugin(plugin).Init())
}

//export ClapGo_PluginDestroy
func ClapGo_PluginDestroy(plugin unsafe.Pointer) {
	if p := getPlugin(plugin); p != nil {
		p.Destroy()
		// Unregister from all providers
		api.UnregisterAudioPortsProvider(plugin)
		api.UnregisterVoiceInfoProvider(plugin)
		api.UnregisterNotePortProvider(plugin)
		// Delete the handle to free the Go object
		cgo.Handle(plugin).Delete()
	}
}

//export ClapGo_PluginActivate
func ClapGo_PluginActivate(plugin unsafe.Pointer, sampleRate C.double, minFrames C.uint32_t, maxFrames C.uint32_t) C.bool {
	return C.bool(getPlugin(plugin).Activate(float64(sampleRate), uint32(minFrames), uint32(maxFrames)))
}

//export ClapGo_PluginDeactivate
func ClapGo_PluginDeactivate(plugin unsafe.Pointer) {
	getPlugin(plugin).Deactivate()
}

//export ClapGo_PluginStartProcessing
func ClapGo_PluginStartProcessing(plugin unsafe.Pointer) C.bool {
	api.DebugMarkAudioThread()
	defer api.DebugUnmarkAudioThread()
	return C.bool(getPlugin(plugin).StartProcessing())
}

//export ClapGo_PluginStopProcessing
func ClapGo_PluginStopProcessing(plugin unsafe.Pointer) {
	api.DebugMarkAudioThread()
	defer api.DebugUnmarkAudioThread()
	getPlugin(plugin).StopProcessing()
}

//export ClapGo_PluginReset
func ClapGo_PluginReset(plugin unsafe.Pointer) {
	getPlugin(plugin).Reset()
}

//export ClapGo_PluginProcess
func ClapGo_PluginProcess(plugin unsafe.Pointer, process unsafe.Pointer) C.int32_t {
	api.DebugMarkAudioThread()
	defer api.DebugUnmarkAudioThread()
	return C.int32_t(getPlugin(plugin).ProcessWithHandle(process))
}

//export ClapGo_PluginGetExtension
func ClapGo_PluginGetExtension(plugin unsafe.Pointer, id *C.char) unsafe.Pointer {
	return getPlugin(plugin).GetExtension(C.GoString(id))
}

//export ClapGo_PluginOnMainThread
func ClapGo_PluginOnMainThread(plugin unsafe.Pointer) {
	getPlugin(plugin).OnMainThread()
}
`

func main() {
	tmpl, err := template.New("exports").Parse(exportTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}
	
	// Generate to stdout - can be redirected to a file
	err = tmpl.Execute(os.Stdout, nil)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}
}