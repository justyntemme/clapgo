# Shared Code Analysis

This document identifies code that is duplicated across plugins and should be moved to the ClapGo library.

## State Management

### SaveStateToStream / LoadStateFromStream
Both gain and synth plugins implement identical stream-based state saving/loading:

**Current duplication:**
- `SaveStateToStream(stream unsafe.Pointer) bool`
- `LoadStateFromStream(stream unsafe.Pointer) bool`

**Proposed library solution:**
```go
// In pkg/api/state.go
type StateHandler struct {
    paramManager *ParameterManager
}

func (s *StateHandler) SaveToStream(stream unsafe.Pointer, customData map[string]interface{}) bool
func (s *StateHandler) LoadFromStream(stream unsafe.Pointer) (map[string]interface{}, bool)
```

## Parameter Export Functions

### Parameter-related CGO exports
All plugins must implement these identical exports:

**Current duplication:**
```go
//export ClapGo_PluginParamsCount
//export ClapGo_PluginParamsGetInfo
//export ClapGo_PluginParamsGetValue
//export ClapGo_PluginParamsValueToText
//export ClapGo_PluginParamsTextToValue
//export ClapGo_PluginParamsFlush
```

**Proposed library solution:**
Generate these exports automatically based on a plugin's ParameterManager instance.

## State Export Functions

### State-related CGO exports
All plugins implementing state must have:

**Current duplication:**
```go
//export ClapGo_PluginStateSave
//export ClapGo_PluginStateLoad
```

**Proposed library solution:**
Generate these exports automatically when a plugin implements a StateProvider interface.

## Atomic Float Operations

### Float/Bits conversion
Both plugins duplicate these helper functions:

**Current duplication:**
```go
func floatToBits(f float64) uint64
func floatFromBits(b uint64) float64
```

**Proposed library solution:**
Move to `pkg/api/params.go` (already exists there).

## Common Plugin Lifecycle

### Plugin lifecycle exports
Every plugin must implement:

**Current duplication:**
```go
//export ClapGo_CreatePlugin
//export ClapGo_PluginInit
//export ClapGo_PluginDestroy
//export ClapGo_PluginActivate
//export ClapGo_PluginDeactivate
//export ClapGo_PluginStartProcessing
//export ClapGo_PluginStopProcessing
//export ClapGo_PluginReset
//export ClapGo_PluginProcess
//export ClapGo_PluginGetExtension
//export ClapGo_PluginOnMainThread
```

**Proposed library solution:**
These should be generated by the code generator based on the plugin type.

## Extension Handling

### GetExtension implementation
Both plugins have similar patterns for extension handling:

**Current duplication:**
```go
func (p *Plugin) GetExtension(id string) unsafe.Pointer {
    switch id {
    case api.ExtParams:
        // Return params extension
    case api.ExtState:
        // Return state extension
    // ... etc
    }
}
```

**Proposed library solution:**
Create an ExtensionRegistry that automatically handles standard extensions based on what interfaces the plugin implements.

## Event Processing

### Parameter event processing
Both plugins process parameter events similarly:

**Current duplication:**
- Iterating through events
- Filtering parameter events
- Applying parameter changes

**Proposed library solution:**
The ParameterManager should have a method like:
```go
func (pm *ParameterManager) ProcessEvents(events EventHandler) 
```

## Implementation Priority

1. **High Priority** (Most benefit, least disruption):
   - State management helpers
   - Atomic float operations (already in library)
   - Parameter event processing

2. **Medium Priority** (Good benefit, moderate effort):
   - Extension registry system
   - Common parameter formatting/parsing

3. **Low Priority** (Requires code generation changes):
   - Automatic export generation
   - Lifecycle management

## Migration Strategy

1. Start by creating the shared implementations in the library
2. Update one plugin at a time to use the shared code
3. Update the code generator to use the shared implementations
4. Document the new patterns in examples

## Benefits

- Reduced code duplication
- Consistent behavior across all plugins
- Easier maintenance and bug fixes
- Simpler plugin development
- Better test coverage (test once in library)